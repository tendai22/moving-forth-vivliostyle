# Part 8: CamelForth for the 6809

> This article first appeared in The Computer Journal #74 (July/August 1995).

ついに "Moving Forth!" の最終回です。長い間約束されていた、Motorola 6809用、特にScroungmaster IIプロセッサボード用のANSI CamelForthを紹介します。

Z80や8051のCamelForthとは異なり、6809のForthは私の"Chromium 2"Forthメタコンパイラ [ROD92]で作成されたものです。まず、メタコンパイラが古いForth(F83)で動作しているため、ソースコードは16x64のForth "スクリーン" に含まれています。私はこれをTCJ用にASCIIファイルに変換しましたが、オリジナルの書式はまだ残っています。

次に、Forthメタコンパイラのソースコードは、普通のForthのコードと同じように見えます(少し変更されていますが、それについては後ほど説明します)。したがって、1+の定義は次のように与えられます。
```
  CODE 1+   1 # ADDD,   NEXT   ;C  
```
使用したアセンブラは、以前TCJ [ROD91]で紹介した6809アセンブラです。

高レベルのソースコードは、すでに公開されているリストから直接入力しました(その過程でForthの構文に変換しました)。残念ながら、この作業は数日間に渡って行われ、あるときはZ80のリストから、またあるときは8051のリストから作業しました...その結果、6809のコードではハーバード・アーキテクチャの構成要素(I@やIALLOTなど)が一貫して使用されていないことがわかりました。これは非ハーバードの6809には関係ないことですが、ForthのコードをハーバードCPUに移植する前に修正する必要があります。

また、公開されているリストをもとに作業していたため、高級なワードに対する詳細なコメントの入力がおろそかになることが多々ありました。この点については、申し訳なく思っています。どのワードがどのように動作するかは、過去のリストを参照すればわかりますが、これを無理強いしてはいけませんね。

# [6809 CAMELFORTH SOURCE CODE](camel09.txt)

6809 CamelForth モデルでは、D でTop-of-Stackを保持し、S スタックポインタをパラメータスタックに使用します。Uスタックポインタはリターンスタックポインタ、Yはインタプリタポインタです。Xはテンポラリレジスタ "W" です。6809のダイレクトページポインタDPRは、ユーザポインタの上位バイトを保持します(下位バイトは0とします)。

8KのRAMと8KのEPROMを持つScroungemaster IIのメモリマップは次のようになります。
```
 6000-797Fh RAM dictionary (for new definitions)
 7980-79FFh Terminal Input Buffer
 7A00-7A7Fh User Area (USER variables)
 7A80-7AFFh Parameter Stack (grows downward)
 7B00-7B27h HOLD area (grows downward) 
 7B28-7B7Fh PAD area (general purpose buffer)
 7B80-7BFFh Return Stack (grows downward)

 E000-FFFFh Forth kernel in EPROM
```
すべてのRAMデータエリアは、ユーザポインタを参照しています。この初期値はUP-INITで指定します。この場合、7A00hです。(この値の上位バイトを指定する場合は、UP-INIT-HIを使います) CamelForthが起動すると、辞書ポインタにDP-INITを設定します。これは、Forth辞書に新しい定義を追加できるようにRAM内を指す必要があります。これらはすべて、メタコンパイラのEQUディレクティブで指定します。EQUはCONSTANTと似ていますが、メタコンパイラーにしかわからないという点が異なります。これらのEQUは6809カーネルでスペースを取らず、6809 Forthの辞書にも表れません。

DICTIONARYはメタコンパイラにコードをコンパイルする場所を指示します。この場合、E000-FFFFhの8K EPROM用です。新しい辞書は"ROM"と名付けられ、その辞書を選択するためにROMが指定されます。(Forthのボキャブラリに慣れている人なら、強い類似性があることが分かるでしょう)。

AKA("also known as")は、Forthのワードの同義語を定義します。6809は非ハーバードアーキテクチャマシンなので、I@がソースコードのどこに出てきても@をコンパイルしなければなりませんし、他の"I-プレフィックス"(命令空間)のワードについても同様です。AKAがこれを行います。これらの同義語はEQUATEのようなもので、6809の辞書には出てきません。

メタコンパイラでは、前方参照、つまりまだ定義されていないForthのワードを使うことができます。(もちろん、終了する前に定義しなければなりません!) 多くの場合、これは自動的ですが、AKAはPRESUMEで明示的に前方参照を宣言することを要求します。このように
```
  PRESUME WORD   AKA WORD IWORD   
```
はIWORDのシノニムを作成するために必要です。@ ! HERE ALLOTなどはメタコンパイラでPRESUMEされているので、ここではその必要はありません。

コード定義は従来通りです。なお
```
  HERE EQU labelname  
```
を使用して、メタコンパイル時にラベルを生成します(これはメタコンパイラの機能であり、アセンブラではありません)。 また、ASM:はアセンブラコードの"断片"(つまり、コードワードの一部ではない)を開始します。

以下のフレーズ、
```
  HERE RESOLVES name 
```
は、メタコンパイラが行う特定の前方参照を解決するために使用されます (たとえば、メタコンパイラは DOCOLON アクションのコードがどこにあるかを知っておく必要があります)。これらはそのままにしておかねばなりません。それ以外の場合は、コード の定義を自由にソースコードに追加してください。

ワードと制御構造(IMMEDIATEワード)を定義するためのコードは、どちらかというと不透明です。これは、これらのワードがメタコンパイル中にも何らかの動作をしなければならないからです。例えば、6809 Forthには、新しい定数を定義するためのCONSTANTという標準的なワードがあります。しかし、CONSTANTは6809カーネルにも現れるかもしれません。メタコンパイル中にCONSTANTを定義しなければならないかもしれません。EMULATE: はメタコンパイラに CONSTANT というワードがあった場合にどのように処理するかを指示します。このフレーズは全てメタコンパイラのワードを使って書かれているので、全くちんぷんかんぷんなように見えるかもしれません。

同様に、IF THENとその類は、6809イメージの分岐を構築し解決するためのメタコンパイラフレーズを含んでいます。Forthのメタコンパイラの中には、このコードをコンパイラの中に埋め込んでしまうものがあります。このため、ターゲットコードはきれいになりますが、例えばブランチの動作方法を変更する場合、メタコンパイラを手術する必要があります。私は、これらの動作を簡単に変更できるようにすることが望ましいと考え、Chromiumを設計し、ターゲットのソースコードにそれらを配置するようにしました(最も恐ろしい例は、TENDLOOPとTS"の定義で、これは実際にターゲットソースコードの途中でメタコンパイラの語彙を拡張しています)。

Forthやメタコンパイラを初めて使う人は、これらの定義をそのまま受け入れるのが一番です。"普通の"コロン定義は、簡単に追加できます。6809の残りのソースコードの例に従えばよいのです。メタコンパイラの中で使う必要がない限り、CREATE..DOES>の定義も作ることができます。

# FUTURE WORK
1MHzの6809では、1行のテキスト入力の処理にかなりの時間がかかります(概算で1秒程度まで)。これは、インタプリタの多くが高水準のForthで書かれていることと、CamelForthが単方向リンクリスト辞書を使用していることが一因です。これらのハンディキャップは**コンパイル速度**に影響するだけで、実行速度には影響しませんが、この遅延は煩わしいものです。いつか"Forthの高速化"についての記事を書くかもしれません。

現在、ユーザポインタは決して変更されません。ユーザポインタを持つ理由は、マルチタスクをサポートするためです。各タスクは別々のユーザエリアやスタックなどを持ちます。これについては、近々取り組むつもりです。また、SM IIのメモリ管理を利用して、各タスクに32Kのプライベートディクショナリを持たせることも検討するつもりです。もちろん、共有バスを使った真の**マルチプロセッサ**の Forth カーネルも書くつもりです。もし私が長生きすれば、シリアルポートを使った**分散型** Forth カーネル (Transputer のようなもの) が次のステップとなるでしょう。

6809 CamelForth、バージョン1.0のソースコードは、GEnieのForth RoundtableにあるCAM09-10.ZIPというファイルで入手可能です。このファイルには、Chromium 2 メタコンパイラが含まれており、完全な形ですぐに実行できます。F83のコピーの用意が必要です。そして、次のようにタイプするだけです。
```
  F83 CHROMIUM.SCR
  1 LOAD
  BYE 
```
これはメタコンパイラをロードし、6809 CamelForthをコンパイルし、その結果をIntel HEXファイル6809.HEXに書き込みます。注意：もし CP/M や Atari ST 版の F83 を使っているならば、MS-DOS でしか動作しないので、hex ファイルユーティリティを削除するためにロードスクリーンを編集する必要があるでしょう。Chromium 2 はまだ CP/M や Atari ST でテストしていませんので、もしサポートが必要な場合は、私に連絡してください。

そういえば、新しい電子メールアドレスができました! GEnie のユーザなら bj@genie.com か BJ として連絡できます。より簡単に入力できるようになりました。[ウェブ掲載用メモ：現在のメールアドレスはこちらです]。

# ERRATA
CamelForth/8051 のハーバードメモリアクセスに一部誤りがありました。修正したファイルを CAM51-11.ZIP として GEnie にアップロードしました。また、TCJに掲載された修正をすべて盛り込んだ現在のZ80 CamelForth、CAM80-12.ZIPをアップロードしました。

# REFERENCES
[ROD91] Rodriguez, B. J., "B.Y.O. Assembler," The Computer Journal #52 (Sep/Oct 1991) and #54 (Jan/Feb 1992).

[ROD92] Rodriguez, B. J., "Principles of Metacompilation," Forth Dimensions XIV:3 (Sep/Oct 1992), XIV:4 (Nov/Dec 1992), and XIV:5 (Jan/Feb 1993). Describes the "Chromium 1" metacompiler.

Source code for 6809 CamelForth is available on this site at http://www.camelforth.com/public_ftp/cam09-10.zip.
