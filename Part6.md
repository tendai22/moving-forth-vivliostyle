# Part 6: the Z80 high-level kernel

> This article first appeared in The Computer Journal #69 (September/October 1994).

# ERRATA
TCJ#67で紹介したCAMEL80.AZMファイルには、2つの誤りがあります。一つは、Forthワード>のHEADマクロで指定する名前の長さが、1ではなく2と間違って入力されていたことです。

大きな誤りは、CP/MのコンソールI/Oの微妙な違いに起因するものです。`KEY`は入力された文字をエコーしてはならないので、BDOSのファンクション6を使用しました。`KEY?`はBDOSファンクション11を使用して、キー入力の有無を非破壊でテストしていました。残念ながら、BDOSファンクション6はファンクション11で検出されたキー入力を"クリア"しないのです! そこで、KEY?をBDOSの6番ファンクションを使うように書き直しました(リスト1)。これは"破壊的"なテストなので、"消費された"キー入力を保存し、次にKEYを使用するときにそれを戻すロジックを追加する必要がありました。この新しいロジックは、ハードウェア(またはオペレーティングシステム)がキー押下の破壊的テストしか提供しない場合に使用できます。

# HIGH LEVEL DEFINITIONS
前回は、ソースコードについてあまり詳しく説明しませんでしたが、今回は、Forthのプリミティブについて説明します。Forthの"プリミティブ"は、それぞれ極小の、明確に定義された機能を実行するものです。ほとんどがZ80アセンブラのコードで、あるワードがなぜ含まれるのかが明らかでなくても、それぞれのワードが何をするのかが明らかであればいいと思っています。

今回は、そんな贅沢は言わない。Forth言語のエレガントな(そして曲がりくねった)論理を体現する高レベルの定義を紹介しよう。Forthカーネルについて書かれた本[1,2,3]がたくさんありますが、もし完全にマスターしたければ、そのうちの1冊を買うことを強くお勧めします。TCJでは、リスト2に示したコンパイラとインタプリタのキーワードのいくつかに限定して説明します。

# TEXT INTERPRETER OPERATION
テキストまたは"外側"のインタープリタは、キーボードからの入力を受け入れ、希望するForthの操作を実行するForthコードです(これは、コンパイルされたスレッドコードを実行するアドレスまたは"内側"のインタープリタNEXTとは別のものです)。これを理解する最良の方法は、Forthシステムのスタートアップを通じて作業することです。

1. CP/Mのエントリポイント(前回のリストを参照)は、利用可能なメモリの先頭を決定し、スタックポインタ(PSP、RSP)とユーザポインタ(UP)を設定し、図1に示すメモリマップを確立する。そして、Forthワード`COLD`を実行するために"内部"インタプリタ・ポインタ(IP)を設定する。

2. `COLD`はスタートアップテーブルからユーザ変数を初期化し、`ABORT`を実行します。(加えて、`COLD`はCP/Mのコマンドラインで指定されたForthコマンドを実行しようとします)。

3. `ABORT`はパラメータスタックポインタをリセットし、`QUIT`を実行する。

4. `QUIT`は、復帰スタックポインタ、ループスタックポインタ、解釈状態をリセットし、Forthコマンドの解釈を開始します。(`QUIT`はアプリケーションを中断し、Forthの"トップレベル"に戻るために使用されるため、この名前は適切です。`ABORT`とは異なり、`QUIT`はパラメータスタックの内容だけを残します)。`QUIT`は無限ループで、キーボードから1行を`AACEPT`し、それをForthのコマンドとして解釈します。コンパイルしていないとき、`QUIT` は各行の後に "ok" のプロンプトを出力します。

5. `INTERPRET`はANS Forth文書の3.4節で示されたアルゴリズムをほぼそのまま翻訳したものです。これは入力からスペースで区切られた文字列1つを切り出し、その名前を持つForthワードを`FIND`しようとします。ワードが見つかった場合、それは実行されるか(IMMEDIATEワードである場合、または"解釈"状態である場合、STATE=0)、辞書にコンパイルされます("コンパイル"状態である場合、STATE<>0)。ワードが見つからない場合、Forthはその文字列を数値として変換しようとします。成功した場合、LITERALはそれをパラメータスタックに配置するか("interpret"状態にある場合)、インラインリテラル値としてコンパイルします("compile"状態にある場合)。Forthのワードでもなく、有効な数値でもない場合、その文字列は出力され、エラーメッセージが表示され、インタープリタは`ABORT`します。この処理は、文字列ごとに、入力行の最後に達するまで繰り返されます。

# THE FORTH DICTIONARY
おっ！インタプリタはどうやってForthのワードを名前で"探す"のか? その答えは Forthは、すべてのForthワードの名前の"辞書"を保持しています。各名前は、対応するワードの実行コードと何らかの方法で接続されています。

検索用の文字列の集合を保存する方法はたくさんあります：単純な配列、リンクリスト、多重リンクリスト、ハッシュテーブルなどです。Forthが求めるのは、名前を再利用する場合、辞書を検索したときに***最新***の定義が見つかるということだけです。

また、複数の名前のセット("ボキャブラリ"、新しいANSIの専門用語では"ワードリスト")を持つことも可能です。これにより、以前の意味を失うことなく、名前を再利用することができる。例えば、整数の`+`、浮動小数点の`+`、文字列の`+`など...オブジェクト指向のコミュニティで好まれる"演算子のオーバーロード"を実現する方法の1つです。

各文字列は、実行コードの関連付けのため、メモリ上で物理的に隣接させて置くことが可能です。つまり、名前はメモリ上で実行コードの直前に配置されるため、Forthワードの"ヘッド"または"ヘッダ"と呼ばれます。また、文字列はメモリの全く別の場所にあり、実行コードへのポインタで接続されている場合もあります("セパレートヘッド")。

コンパイルや解釈が必要ないと分かっている場合は、名前のない("ヘッドレス")Forthコードの断片を持つことも可能です。ANSIは、ANS Forthのワードが検索可能であることだけを要求しています。

設計上の決定事項については、別の記事で紹介します。CamelForthは、実行コードの直前にヘッダを配置した単方向リンクリストという、最もシンプルな方式を採用していると言えば、それで十分でしょう。ボキャブラリはありません...将来のTCJで追加するかもしれませんが。

# HEADER STRUCTURE (FIGURE 2)
ヘッダにどのようなデータを入れるか、またどのように格納するか。

最小限必要なデータは、名前、優先度ビット、実行可能コードへのポインタ(明示的または暗黙的)です。簡単のために、CamelForthは名前を"カウントされた文字列"(長さを表す1バイトの後ろに文字N個が続く)として保存します。Early Forth社製品では、比較の高速化のため、長さはあっても最初の3文字しか保存しませんでした(これで実際に得られる改善は、ここでは議論しませんが、ホットな議論になります)。Fig-Forthは妥協して、最後の文字のMSBをhighにすることでフラグを立て、完全長の名前、または切り詰められた名前のいずれかを許可するようにしました。他のForthsではパックされた文字列[4]が使われていますし、C言語風の、ヌル文字で終端された文字列もどこかで使われているのではないかと思っています。

"優先ビット"は、このワードがIMMEDIATE状態であるかどうかを示すフラグです。IMMEDIATEワードはコンパイル中も実行されます。このようにして、Forthはコンパイラディレクティブと制御構造体を実装しています。コンパイラディレクティブを区別するためには、別の方法もあります。例えば、Pygmy Forth [5]では、コンパイラディレクティブを別のボキャブラリにまとめています。しかし、ANS Forthは基本的に優先順位ビット(precedence bit)[6]の使用を義務付けています。多くのForthはこのビットを"length"バイトに格納しています。私は、ワード名に対して"通常の"文字列演算子(例えば、`FIND`の中で`S=`、`WORDS`の中で`TYPE`を使うなど)を使用するために、別のバイトに格納することにしています。

名前がリンクリストに保持されている場合、リンクが存在することが必要です。通常、最新のワードがリンクリストの先頭にあり、リンクは前のワードを指しています。これはANSIの(そして伝統的な)再定義されたワードに対する要求を実施するものです。Charles Curley [7]はリンクフィールドの配置を研究し、リンクフィールドが名前の前(Fig-Forthのように後ではなく)に来ると、コンパイラが著しく高速化されることを発見しました。

図2は、CamelForthのワードヘッダと、比較のためにFig-Forth、F83、Pygmy Forthのヘッダの構造を示しています。F83 Forthと Pygmy Forthの "view" フィールドは、Forth のワードヘッダに他の有用な情報を格納できることの一例です。

覚えておいてほしいのは、重要なことは、ワードのヘッダと"本体(body)"(実行可能な部分)を区別できることである、ということです。これらを一緒に保存する必要はありません。ヘッダはコンパイル時と解釈時にのみ使用され、"純粋に実行可能な"Forthアプリケーションでは、ヘッダを完全に省くことができます。しかし、ヘッダは、少なくともANSIワードセットについては、合法的なANS Forth Systemであるために、存在しなければなりません。

アセンブラのソースコードからForthシステムを"コンパイル"する場合、このヘッダを構築するマクロを定義することができます(CAMEL80.AZMのHEADとIMMEDを参照してください)。Forth環境では、ヘッダとコードフィールドは`CREATE`というワードで構築されます。

# COMPILER OPERATION
これで、Forthコンパイラを理解するのに十分な知識が得られました。ワード`:`は、ワードのヘッダを作成し(`CREATE`)、そのコードフィールドを"ドコロン"(`!COLON`)に変更し、コンパイル状態に切り替える(`]`)ことによって、新しい高レベル定義を開始します。コンパイル状態では、テキストインタープリタが出会ったすべてのワードは、実行されるのではなく、辞書にコンパイルされることを思い出してください。これは、`;`というワードに出会うまで続けられます。IMMEDIATEのワードとして `;` は実行され、`EXIT`をコンパイルして定義を終了し、解釈状態(`[`)に戻ります。

また、`:`は新しいワードを`HIDE`し、`;`はそれを(名前の"smudge"ビットの設定と解除によって)`REVEAL`します。これは、Forthのワードを"以前の自分"を用いて再定義できるようにするためのものです。現在定義中のワードを強制的に再帰的に呼び出すには、`RECURSE`を使用します。

こうしてみると、CやPascalのコンパイラと同じ意味で、Forthには明確な"コンパイラ"が存在しないことが分かります。Forthのコンパイラは、さまざまなForthのワードの動作の中に具現化されています。このため、コンパイラを変更したり拡張したりすることは容易ですが、一方で、組み込みのコンパイラなしでForthアプリケーションを作成することは困難です。

# THE DEPENDENCY WORD SET
残りの高レベルのワードのほとんどは、a) コンパイラとインタプリタを実装するために必要なものか、b) 単にプログラミングを楽しむために用意されたものです。CAMEL80D.AZM([リスト3](camel80d.txt))というファイルに分離したものです。

ANSI Forth Standardの目的の1つは、CPU依存性とモデル依存性(Direct Threaded か Indirect Threadedか? 16ビットか32ビットか?)を隠ぺいすることでした。この目的のために、いくつかのワードが標準に追加されました。私はこれをさらに一歩進めて、***カーネル内でも***これらの依存関係をカプセル化することを試みました。理想的には、CAMEL80H.AZMファイル内の高レベルForthコードは、すべてのCamelForthのターゲットCPUで同じであるべきです(ただし、アセンブラが異なれば構文も異なりますが)。

セルサイズとワードアライメントの違いは、ANS Forthのワード**`ALIGN`**, `ALIGNED`,  `CELL+`,  `CELLS`,  `CHAR+`, `CHARS`と私自身が追加した`CELL`(`1 CELLS`と同等だがコンパイルすると小さくなる)によって扱います。

`COMPILE,`, `!CF`, `,CF`, `!COLON`, `,EXIT`というワードは、a)スレッドをどのように表現するか、b)コードフィールドはどのように実装するか、といったスレッドモデルの特殊性を隠します。これらの言葉の価値は、ダイレクトスレッドのZ80とサブルーチンスレッドの8051の違いを見れば明らかです。

```
 
 word     compiles on Z80   compiles on 8051

 COMPILE, address           LCALL address
 !CF      CALL address      LCALL address
 ,CF      !CF & allot       3 bytes !CF & allot 3 bytes
 !COLON   CALL docolon      nothing!
 ,EXIT    address of EXIT   RET
(!CF and ,CF are different for indirect-threaded Forths.)
```

同様に、`,BRANCH` `,DEST` , `!DEST`というワードは、高レベルのブランチやループ演算子の実装を隠しているのです。私は、既存のForthsから借用することなく、すべての実装の違いを考慮できる最小限の演算子のセットを発明しようと試みました! 時間、専門家の批評、そして多くのCamelForthsだけが、私がどれだけ成功したかを語ることができるでしょう。

今のところ、私はヘッダ構造の違いを同じような言葉の集合に置き換えることに**成功していません***。`FIND`と`CREATE`というワードはヘッダの内容と非常に密接に関係しているため、適切なサブファクターがまだ見つかっていないのです。まずは、`NFA>LFA`,  `NFA>CFA` ,`IMMED?`, `HIDE`, `REVEAL`というワードから始めました。`HIDE`, `REVEAL`とANS Forthのワード `>BODY`, `IMMEDIATE`でスタートしました。今後も続けていくつもりです。幸いなことに、すべてのCamelForthの実装で同一のヘッダ構造を使用することは、当面の間、実用的です(これらはすべてバイトアドレスの16ビットForthであるため)。

# NEXT TIME...
おそらく 8051 のカーネルを説明し、Forth のコンパイラとインタプリタがハーバード・アーキテクチャ(8051 のようにコードとデータ用に論理的に異なるメモリを持つコンピュータ)用にどのように変更されているかを話すと思います。8051 については、CAMEL51 と CAMEL51D のファイルを印刷しますが、おそらく CAMEL51H については、高レベルコードは本稿で説明したモノと違いがないはず(アセンブリ言語ファイルとしての書式の違いを除けば)で、またBillが紙面を他の原稿に回す必要もあるでしょうし、抜粋のみを印刷する予定です。心配しないでください、完全なコードはGEnieにアップロードされる予定です。

しかし、Scroungemaster IIのビルダーの要求に屈して、Scroungemaster IIボード用に構成した6809 CamelForthを公開するかもしれません。どちらにしても、もう一方はその後にやります。

# REFERENCES
1. Derick, Mitch and Baker, Linda, Forth Encyclopedia, Mountain View Press, Route 2 Box 429, La Honda, CA 94020 USA (1982). Word-by-word description of Fig-Forth.

2. Ting, C. H., Systems Guide to fig-Forth, Offete Enterprises, 1306 South B Street, San Mateo, CA 94402 USA (1981).

3. Ting, C. H., Inside F83, Offete Enterprises (1986).

4. Ewing, Martin S., The Caltech Forth Manual, a Technical Report of the Owens Valley Radio Observatory (1978). This PDP-11 Forth stored a length, four characters, and a link in two 16-bit words.

5. Sergeant, Frank, Pygmy Forth for the IBM PC, version 1.4 (1992). Distributed by the author, available from the Forth Interest Group (P.O. Box 2154, Oakland CA 94621 USA) or on GEnie.

6. J. E. Thomas examined this issue thoroughly when converting Pygmy Forth to an ANSI Forth. No matter what tricks you play with relinking words, strict ANSI compliance is violated. A regrettable decision on the part of the ANS Forth team.

7. In private communication.

Z80 CamelForth のソースコードが CAMEL80.ARC として GEnie の CP/M and Forth Roundtables で公開されています。実を言えば、たった今アップロードしました(お待ちいただいていた方には申し訳ありません)。

Source code for Z80 CamelForth is available on this site at http://www.camelforth.com/public_ftp/cam80-12.zip.

# FIGURE 1. Z80 CP/M CAMELFORTH MEMORY MAP

```
assuming CP/M BDOS starts at ED00 hex.

0000 +-----------------------+
     |      CP/M stuff       |
0080 +-----------------------+
     | Terminal Input Buffer |
     |                       |
0100 +-----------------------+
     |                       |
     | CamelForth Z80 kernel |
     |                       |
1700 +-----------------------+
     | User definitions      |
     |                       |
     |                       |   / EB00 reserved     
     ~~~~~~~~~~~~~~~~~~~~~~~~~  /  EB02 >IN          
     |                       | /   EB04 BASE         
EB00 +-----------------------+/    EB06 STATE        
     | User Area             |     EB08 DP           
     |                       |\    EB0A,EB0C 'SOURCE
     |                       | \   EB0E LATEST       
     |       Parameter Stack |  \  EB10 HP           
EC00 +-----------------------+   \ EB12 LP           
     |                       |
     |   HOLD working buffer |
EC28 +-----------------------+
     | PAD buffer            |
     |                       |
EC80 +-----------------------+
     | Leave stack*          |
     |                       |
     |                       |
     |          Return stack |
ED00 +-----------------------+
     |                       |
     |         CP/M          |
     |                       |
FFFF +-----------------------+
* used during compilation of DO..LOOPs.
```
# FIGURE 2. HEADER STRUCTURES

```
    CamelForth        Fig-Forth          Pygmy Forth            F83
                                                        
 D7           D0    D7           D0    D7           D0    D7           D0
+---------------+  +-+-+-+---------+  +---------------+  +---------------+
|               |  |1|P|S| length  |  |               |  |               |
|-    link     -|  +-+-+-+---------+  |-    view     -|  |-    view     -|
|               |  |               |  |               |  |               |
+-------------+-+  |-    name     -|  +---------------+  +---------------+
|      0      |P|  |               |  |               |  |               |
+-+-----------+-+  ~~~~~~~~~~~~~~~~~  |-    link     -|  |-    link     -|
|S|   length    |  |               |  |               |  |               |
+-+-------------+  +-+            -|  +-+-+-+---------+  +-+-+-+---------+
|               |  |1|             |  |0|0|S| length  |  |1|P|S| length  |
|-    name     -|  +-+-------------+  +-+-+-+---------+  +-+-+-+---------+
|               |  |               |  |               |  |               |
~~~~~~~~~~~~~~~~~  |-    link     -|  |-    name     -|  |-    name     -|
|               |  |               |  |               |  |               |
|-             -|  +---------------+  ~~~~~~~~~~~~~~~~~  ~~~~~~~~~~~~~~~~~
|               |                     |               |  |               |
+---------------+                     |-             -|  +-+            -|
                                      |               |  |1|             |
                                      +---------------+  +-+-------------+
```
`Link` - CamelForth および Fig-Forth では、前のワードのLengthバイトの位置を指します。Pygmy Forth と F83 では、直前のワードの Link を指します。

`P` - 優先(Precedence)ビット、IMMEDIATE ワードの場合は 1 になる (Pygmy では使用されない)。

`S` - Smudge ビット、FIND がこのワードを見つけるのを防ぐために使用されます。

`1` - Fig-Forth と F83 では、lengthバイトと名前の最後の文字の最上位ビット(ビット7) に 1 のフラグを立てます。

`View` - Pygmy ForthとF83では、このワードのソースコードのブロック番号が含まれています。

Continue with Part 7 | Back to publications page